## Design proposal: process manager API

This document outlines design proposal for a prototype of a service API to manage Linux processes.

The service is implemented as a server, allowing multiple concurrent client connections.

### Library

The library is the core of the server, which does the following:
 - exposes gRPC endpoint with mTLS
 - implements protos and API calls for
   - starting a process
   - stopping a process
   - getting process status
   - streaming process output
 - performs API authorization

The server maintains a map of processes, both active and stopped. The key is a UID generated by the server (not to be confused with PID assigned by the OS). The values is a structure represents the process.

### API implementation

`start`:
 - Input: executable name and optional list of arguments.
 - Output: process UID.
 - Action: The server generates a UID, starts the process, and adds a new entry to the process map. The process output is forwarded to a file.

`stop`:
 - Input: process UID.
 - Output: process status.
 - Action: if the corresponding process is running, terminate the process and return status `stopped`. If the process is not in the map, return status `not found`.

`get-status`:
 - Input: process UID.
 - Output: process status.
 - Action: if the process is in the map, return process status. Otherwise return status `not found`.

`stream-output`:
 - Input: process UID.
 - Output: stream of the process output file.
 - Action: if the process is in the map, stream its output file.


### Authentication and authorization

The authentication is implemented via mTLS. The server and the clients are using certificates signed by a common CA.

Each client has individual certificate with a unique Common Name (`CN`).

If the server cannot authenticate the client, the request will be rejected with an error.

The commands below could be used to generate certificates.


```bash
# create CA key pair and self signed certificate
openssl req -x509 -newkey rsa:4096 -keyout ca.key -out ca.crt -days 365 -nodes -subj "/CN=RootCA" -config host.conf

# create key pair and CSR for server and clients
openssl genrsa -out server.key 2048
openssl genrsa -out client1.key 2048
openssl genrsa -out client2.key 2048

openssl req -new -key server.key -subj "/CN=server" -out server.csr
openssl req -new -key client1.key -subj "/CN=client1" -out client1.csr
openssl req -new -key client2.key -subj "/CN=client2" -out client2.csr

# sign CSR with CA
openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 365 -extfile host-server.conf
openssl x509 -req -in client1.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client1.crt -days 365
openssl x509 -req -in client2.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client2.crt -days 365
```

The server maintains authorization matrix of clients and APIs. 

The value of the cell on intersection of a client and an API is a boolean, specifying whether the client is authorized to call the API.

### Client

The client is a console application performing the following steps:
 - initiates gRPC connection over mTLS with the server. The TLS certificate could be passed in the command line or specified via environment variable.
 - provides CLI to invoke API call with the server.
 - produces necessary output.
